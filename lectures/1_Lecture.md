# Python (в профессиональной разработке скачивают Pycharp)
- высокоуровневый, интерпретируемый(это не С#, когда скопированный на фле байт-код будет работать, тут если нет интерпретатора, то не заработает), кроссплатформенный
- лёгкий синтаксис (низкий порог вхождения)
- множество библиотек

Отступы ломают программу!

Подсказки ctrl+пробел или help(str) или help(text.istitle)(кгда ставим точку подсвечивает)

если : нажать Q

## МОЖНО ДЕЛАТЬ
- web, ML(ИИ), DataScience, аналитика, игры(не очень), софт

## Запуск
стрелка вверху, правой(выбрать запустить), если >>> нажать ctrl+Z

## Переменные
Pynhon c динамической типизацией

можно схитрить value=None потом присвоить значение

print(type(a)) узнать тип переменной

Строковые: ''   ""    '"'    "'"   \'   \n

len(text) длина строки

'kj' in text символ в строке

text.isdigit()  

text.islower()

text.replace('старый','новый')

Срезы:  text[-5] пятый с конца
        text[:] все
        text[:2] нулевой и первый
        text[6:-18] с 6 сначала до 18 с конца
        text[0:len(text):6] или text[::6] 1 из 6 (через 5) начиная с первого
        text[::-1]  в обратном порядке
```
x = 50
def func():
    global x             (ЕСЛИ ФУНКЦИЯ В ФУНКЦИИ, ТО unlocal)
    print('x равно', x)
    x = 2
    print('Заменяем глобальное значение x на', x)
func()
print('Значение x составляет', x)
```
несколько переменных: global x, y, z.

Массивов нет, но есть списки, в которых можно(но не нужно) миксовать разные типы данных и вывод списков простой
list[1, 3, 5, 'dfdf', 1.2, True]

Арифметические по приоритету (),**,⊕,⊖, *,/,//,%,+,-
вещественные перемножаются с багами (1,3*3=3,900000000004)
деление идёт с остатком!

!!! Можно умножать строки на число (lalala)

2 << 2 побитовый сдвиг влево, равно 8
11 >> 1 сдвиг вправо даст 5
ПОБИТОВЫЕ: 5 & 3 И даст 1
           5 | 3 ИЛИ даст 7
           5 ^ 3 ИСКЛЮЧИТЕЛЬНО И даст 6
           ~5 НЕ даст 6


Как в других есть   a+=3    f*=3   и т.д.

round(b)     round(a*b, 5)      Округление в выоде :0.4 до четвертого знака

Логические: True, False  неравенства могут быть тройными, четверными и т.д.

>, >=, <=, <, ==, != not, and, or, is, is not, in, not in
** Отсутствуют &, |, ^ **

f=[1,2,3,4]
print(2 in f)     или     print(not 2 in f)
is_odd=f[0]%2==0  или     is_odd=not f[0]%2
print(is_odd)             print(is_odd)  

Ввод: b = input()
      b = int(input())
      b = float(input())

Вывод:  print('a,'-',b,'-',s)
        print('{}-{}-{}'.format(a,b,s))

изменить порядок print('{1}-{2}-{0}'.format(a,b,s))

Интерполяция:  print(f'{a}-{b}-{s}')

        print(list)
```
if a>b:
    print(a)
elif b<a:
    print()
else:
    print(b)


while условие:
     делаем
     делаем
else:
     делаем
далее


for i in enumeration:   
    делаем
```
например, 1,2,3,4,5:   
list:    
МОЖНО РАСПЕЧАТАТЬ ЗНАЧЕНИЯ lisr(range(5))
range(5): выдаёт от 0 до 4    
range(1,5): выдаёт от 1 до 4  
range(1,10,2): 2 это шаг
'qwe-r fty' дайт побуевенную разбивку со всеми знаками и пробелами

```
animals = ["собака", "кошка", "мышь"]
for i, value in enumerate(animals):
print(i, value)
```

Списки:
list = [1,2,3,4,5]

ran = range(1,6) ran и list имеют разныеы типы данных
numders = list(ran)

если через for *2 строковые элементы, то напечатает удвоенные без пробела далее пробел и следующий удвоенный без пробела

colors.append('элемент') добавляет в конец списка

colors.remove('') или del colors[0] удаляет элемент

Функции можно миксовать типы данных
```
def function_name(x):
    if x==1:
        return 'Целое'
    elif x==2.3:
        return 23
    else:
        return    (вернёт NoneType)
```
```
def total(a=5, *numbers, **phonebook):   НЕОПРЕДЕЛЕННОЕ ЧИСЛО АРГУМЕНТОВ!!!
print('a', a)
for single_item in numbers: #проход по всем элементам кортежа
print('single_item', single_item) 
for first_part, second_part in phonebook.items(): #проход по всем элементам словаря
print(first_part,second_part)
print(total(10,1,2,3,Jack=1123,John=2231,Inge=1560))
```